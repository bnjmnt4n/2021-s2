{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"CS2030S Programming Methodology II","title":"Home"},{"location":"index.html#cs2030s-programming-methodology-ii","text":"","title":"CS2030S Programming Methodology II"},{"location":"00-overview.html","text":"Unit 0. Overview Learning Outcomes This unit provides an overview of the aims of CS2030/S and how the key concepts covered in CS2030/S are related to each other. What is This Module About? CS2030/S is designed for students who have gone through a typical basic programming module module and have learned about problem solving with simple programming constructs such as loops, conditions, and functions. In a typical introductory programming module, such as CS1010 and its variants at NUS, students tend to write small program (in the order of tens or hundreds of lines of code) to solve a programming homework, work alone on their code, and move on to solve the next problem once the homework is done. The first aim of CS2030/S is to change the students' mindset and to make them learn to write software that will continue to evolve as software requirement changes, and to write software that will be read and modified by other programmers (including their future selves). The second aim of CS2030/S is to level-up the complexity of programs that the students write, from order of hundreds of lines to thousands of lines. CS2030/S bridges the students between writing toy programs to solve specific problem in CS1010 and writing larger real-world software in their later modules, such as CS2103 Software Engineering. A programming language is the medium in which programmers can express their intention and construct software, and thus is critical to supporting the aims above. With the appropriate features and tools, once can tame the complexity of software, make the code written friendlier to other programmers, and easier to evolve. The third aim of CS2030/S is thus to expand the students' mind on different ways one can construct software and the principles behind some of the programming langauge constructs. In particular, CS2030/S focuses on objects, types, and functions, as three key constructs towards building programmer-friendly software. It covers both object-oriented paradigm and functional paradigm as two different approaches to construct software, with a strong emphasis on type safety. The final aim of CS2030/S is to introduce students to programming language concepts, to bridge them from introductory programming to advanced modules such as programming language design and implementations. Part of CS2030/S introduces students to the design decisions behind some of the constraints and the workings behind the programming language compilation and execution, giving them a glimpse inside the programming system that so far has been mostly treated as a black box in introductory modules. The Choice of Java We decided to use one programming language throughout the module. This decision means that we need to pick a language with static typing and strongly typed, and support both object-oriented and functional programming. Considering multiple factors, we decided to choose Java for CS2030/S, for its popularity, syntax familiarity, and smoother transitions to later modules in the NUS computing curriculum. While Java is definitely not the most elegant programming language when expressing programs in functional style, we hope that students can still learn the principles of functional programming and apply it in other programming languages. This choice is a trade-off between having to switch to a different language in the middle of a module. What This Module is not About This is not a module on Java programming. We will not comprehensively cover Java syntax and features, except those relevant to the concepts we teach. In fact, we will avoid and even ban students from using certain Java features (such as var ) for pedagogical purposes. This is not a module on software engineering either. Software engineering is a broad discipline on its own and deserves another module. Rather, this module is about the programming principles and constructs on top of which programmers can design better software. To motivate the importance of these principles and constructs and see how they can be used, we will inevitably cover some of the software engineering design principles, such as the Liskov's Substitution Principle (the L in SOLID), Tell-Don't-Ask, Composition over Inheritence, etc. But we will not comprehensively cover object-oriented design or software design in general (e.g., we will not cover S,O,I,D in SOLID). Finally, this is a module that focuses on computaional effeciency. We have CS2040/S for that. In CS2030/S, although reducing computational cost still plays a role, this is not the only cost that matters. CS2030/S is also concern with the human cost of debugging or maintaining software. In striving for simpler software that is easier to maintain and extend, we may have to sacrifice the computational efficiency. Taming Complexity in Software Development An underlying theme of CS2030/S is taming complexity in software development. There are objective metrics with which one can measure the complexity of a software, but here, we will loosely define complexity as anything that increases the likelihood of bugs in a program. Let's start by considering a simplified view of what a software program is. One can view a software program as a collection of data variables and instructions on how to modify these variables. A program generally are written to meet a given requirement: given one or more input variables, the program should perform the computation to produce the output variables, in a way that meets the requirement. Often, the program stores information in the intermediate variables while performing the computation. As a student who have gone through an introductory programming module such as CS1010 and its variants, you should be familiar with the view above, and you should have some experience writing program to solve a given computational problem. The program you have written for these introductory modules are small \"toy\" programs mostly -- they consists of only a few hundreds of lines and tens of variables, at most. Software development in the real world, however, is far more complex than what you have experienced. A software rarely solve a well-defined computational problem only. It often requires multiple components, such as user interface, data storage, and business rules, interacting with each other in an intricate manner to attain a set of functionalities. As the requirement of the software becomes more complex, the number of variables that needs to be kept track of increases; the logic of the computation the programmer needs to maintain the states becomes more complicated. Further, it is often that the variables are inter-dependent of each other. For instance, updating a variable might require updating another; how a variable should be updated might depend on another variable. As the number of variables increases, so is the number of relationships between the variables that the programer has to keep track of. Failure to correctly maintain the variables and the relationship between them most likely will lead to bugs. Further, real world software rarely remains static. This property, is again different from what you have experienced in introductory programming module, where once the instructors release a programming homework, they rarely go back and change the requirement. In the real world, software evolves over time -- new features are added, business rules changes, better algorithms are deployed. The code needs to be updated accordingly -- adding new variables and new computation; changing how variables are updated or are dependent on each other. Updating the code of an already-complex software to keep up with the requirement, if not managed properly, can lead to bugs. Real world software is often the product of teamwork from multiple programmers, where the software development process is unlike what you have experienced in your introductory programming module, where you solve your homework individually. When multiple programmers work together, the interdependency between the states need to be communicated and handled properly and consistently across the programmers. One programmer's modification to the code should not introduce bugs into another programmer's code. Since software envolves over time, the notion of \"multiple programmers\" actually applies even to software developed by a single lone programmer across time. Changing one's code should not introduce new bugs to other parts of the code that is written some time ago. Strategies to Tame Complexity Good Software Development Practices If you are taught properly in your introductory programming modules, you should already be familiar with some of the good programming practices that help to tame the complexity and reduce the chances of bugs. These practices include Comment your code: Commenting your code provides in situ communication between you and other programmers on the team, as well as between you and your future self, on the non-obvious purpose of the states and the relationships between the states. Such comments help to enhance the understanding of what the code is doing and to remind whoever is updating to code to modify appropriately when the requirement changes. Use a coding convention: Adhering to a coding convention helps improves code readability, reducing the cognitive barrier when one programmer reads another programmer's code and allowing the reader to understand the code more easily and thoroughly. CS2030/S will continue to enforce these good programming practices. Functions You should also be taught to always break you code down into functions, each one performs a simple, specific, task. The functions can then be composed to solve larger and more complex tasks. Functions is an important programming structure in taming code complexity, it allows programmers to (i) compartmentalize computation and its effects, reducing the amount of interactions to a few well defined ones (through arguments and return values); (ii) hide the implementation details so that they can be changed later without affecting other parts of the code; (iii) reuse computations and thus write code that is more succinct and easier to understand/change. In CS2030/S, you will not only continue to break your computation into functions, but we will kick it up several notches. A major part of CS2030/S is to introduce you to more programming paradigms and language tools that allow you to compartmentalize computations, hide details, and reduce repetition. The Abstraction Principle The last point above about why it is important to code in small, reusable functions, follows what is called the Abstraction Principle 1 . The principle states that: \"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\" This principle is something that we will visit over and over again in CS2030/S, applying it to different varying parts of a program. In the case of functions, the \"varying parts\" are the values on which we wish to perform the computation on. We will also apply this principle to (i) types, abstracting them out as generic types or subtypes, and (ii) to sub-computation, abstracting them out as higher-order functions. These concepts: generics, subtypes, higher-order functions, underlies most of the content of CS2030/S. Erecting an Abstraction Barrier Another important strategy for taming complexity is the abstraction barrier . Let's separate the role of a programmer into two, in the context of writing functions: the implementer , who implements the function, and a client , who calls the function. The implementer should compartmentalize the internal states and the implementation of the function, hiding them behind the abstraction barrier, only exposing the parameters and return values as the only communication gateways across the barrier. The abstraction barrier is something that we will refer to repeatedly in CS2030/S as well. We will see how we maintain this barrier not only in the context of functions, but also states and computations on these states together, by encapsulating them as objects , and hiding details from the client through access modifiers . These ideas form two of the core principles of object-oriented programming : encapsulation and abstraction . Code for Change The abstraction barrier, if erected and maintained properly, reduces code complexity. It, however, also reduces the flexibility as the software evolves. If the client wishes to modify the computation protected by the abstraction barrier, it will need the help of the implementer. In CS2030/S, we will see two ways we can modify the computation behind the abstraction barrier, without changing the code behind the barrier . First, we will introduce the concept of inheritence and polymorphism , the other two core principles of object-oriented programming. These object-oriented mechanisms allow programmers to easily extend or modify the behavior of existing code. Second, we will introduce closure , an abstraction to a computation and its environment, that we can pass into the functions behind the abstraction barrier to perform a computation. The second idea, if carried to the extreme in terms of flexibility, leads to the concept of monad in functional programming paradigm. A monad is a computational structure that allows objects to be composed and manipulated in a succint and powerful way. Types Allowing a programmer to change the behavior of the existing code without changing the code could lead to more bugs, if not managed properly. To prevent this, both the programming language system, and the programmers, have to adhere to certain rules when extending or modifying the behavior of the existing code. Java and many other typed languages have type systems -- a set of rules that govern how variables, expressions, and functions interact with each other. You will learn about subtyping and the Liskov Substitution Principle, two notions that are important to constraining how inheritance and polymorphism should be used to avoid bugs. A type system is also an important tools to reduce the complexity of software development. By constraining the interactions among the variables, expressions, functions, it reduces the possible interdependence between these programming constructs. Furthermore, any attempt by programmers to break the constraint can be caught automatically. By utilizing the type system properly, we can detect potential bugs before it manifests itself. A reason CS2030/S chooses to use Java is due to its type system. CS2030/S will introduce the concept of types, subtypes, compile-time vs. run-time types, variants of types, generic types, and type inferences, in the context of Java. We will see how we can define our own types (using classes and interfaces ) and define relationships between them. We will see how we can define generic types and generic functions that takes in types as parameters. These concepts are applicable to many other programming languages. Eliminating Side Effects We have discussed how functions can compartmentalize computations and isolate its complexity to within its body. For this approach to be effective, the function must not have any side effect -- such as updating a variable that is not within the function. Such functions, called pure functions , is one of the key principles of the functional programming paradigm, and is something that we will explore to kick off the section on functional paradigm in CS2030/S. A related idea in object-oriented programming we will cover in CS2030/S is immutability -- once we create an object, the object cannot be changed. In order to update an object, we need to create a new one. With immutability and pure functions, we can guarantee that the same function invoked on the same objects will always return the same value. This certainty can help in understanding and reasoning about the code behavior. This principle is formulated by Benjamin C. Pierce in his book \"Types and Programming Languages.\" \u21a9","title":"0. Overview"},{"location":"00-overview.html#unit-0-overview","text":"","title":"Unit 0. Overview"},{"location":"00-overview.html#learning-outcomes","text":"This unit provides an overview of the aims of CS2030/S and how the key concepts covered in CS2030/S are related to each other.","title":"Learning Outcomes"},{"location":"00-overview.html#what-is-this-module-about","text":"CS2030/S is designed for students who have gone through a typical basic programming module module and have learned about problem solving with simple programming constructs such as loops, conditions, and functions. In a typical introductory programming module, such as CS1010 and its variants at NUS, students tend to write small program (in the order of tens or hundreds of lines of code) to solve a programming homework, work alone on their code, and move on to solve the next problem once the homework is done. The first aim of CS2030/S is to change the students' mindset and to make them learn to write software that will continue to evolve as software requirement changes, and to write software that will be read and modified by other programmers (including their future selves). The second aim of CS2030/S is to level-up the complexity of programs that the students write, from order of hundreds of lines to thousands of lines. CS2030/S bridges the students between writing toy programs to solve specific problem in CS1010 and writing larger real-world software in their later modules, such as CS2103 Software Engineering. A programming language is the medium in which programmers can express their intention and construct software, and thus is critical to supporting the aims above. With the appropriate features and tools, once can tame the complexity of software, make the code written friendlier to other programmers, and easier to evolve. The third aim of CS2030/S is thus to expand the students' mind on different ways one can construct software and the principles behind some of the programming langauge constructs. In particular, CS2030/S focuses on objects, types, and functions, as three key constructs towards building programmer-friendly software. It covers both object-oriented paradigm and functional paradigm as two different approaches to construct software, with a strong emphasis on type safety. The final aim of CS2030/S is to introduce students to programming language concepts, to bridge them from introductory programming to advanced modules such as programming language design and implementations. Part of CS2030/S introduces students to the design decisions behind some of the constraints and the workings behind the programming language compilation and execution, giving them a glimpse inside the programming system that so far has been mostly treated as a black box in introductory modules.","title":"What is This Module About?"},{"location":"00-overview.html#the-choice-of-java","text":"We decided to use one programming language throughout the module. This decision means that we need to pick a language with static typing and strongly typed, and support both object-oriented and functional programming. Considering multiple factors, we decided to choose Java for CS2030/S, for its popularity, syntax familiarity, and smoother transitions to later modules in the NUS computing curriculum. While Java is definitely not the most elegant programming language when expressing programs in functional style, we hope that students can still learn the principles of functional programming and apply it in other programming languages. This choice is a trade-off between having to switch to a different language in the middle of a module.","title":"The Choice of Java"},{"location":"00-overview.html#what-this-module-is-not-about","text":"This is not a module on Java programming. We will not comprehensively cover Java syntax and features, except those relevant to the concepts we teach. In fact, we will avoid and even ban students from using certain Java features (such as var ) for pedagogical purposes. This is not a module on software engineering either. Software engineering is a broad discipline on its own and deserves another module. Rather, this module is about the programming principles and constructs on top of which programmers can design better software. To motivate the importance of these principles and constructs and see how they can be used, we will inevitably cover some of the software engineering design principles, such as the Liskov's Substitution Principle (the L in SOLID), Tell-Don't-Ask, Composition over Inheritence, etc. But we will not comprehensively cover object-oriented design or software design in general (e.g., we will not cover S,O,I,D in SOLID). Finally, this is a module that focuses on computaional effeciency. We have CS2040/S for that. In CS2030/S, although reducing computational cost still plays a role, this is not the only cost that matters. CS2030/S is also concern with the human cost of debugging or maintaining software. In striving for simpler software that is easier to maintain and extend, we may have to sacrifice the computational efficiency.","title":"What This Module is not About"},{"location":"00-overview.html#taming-complexity-in-software-development","text":"An underlying theme of CS2030/S is taming complexity in software development. There are objective metrics with which one can measure the complexity of a software, but here, we will loosely define complexity as anything that increases the likelihood of bugs in a program. Let's start by considering a simplified view of what a software program is. One can view a software program as a collection of data variables and instructions on how to modify these variables. A program generally are written to meet a given requirement: given one or more input variables, the program should perform the computation to produce the output variables, in a way that meets the requirement. Often, the program stores information in the intermediate variables while performing the computation. As a student who have gone through an introductory programming module such as CS1010 and its variants, you should be familiar with the view above, and you should have some experience writing program to solve a given computational problem. The program you have written for these introductory modules are small \"toy\" programs mostly -- they consists of only a few hundreds of lines and tens of variables, at most. Software development in the real world, however, is far more complex than what you have experienced. A software rarely solve a well-defined computational problem only. It often requires multiple components, such as user interface, data storage, and business rules, interacting with each other in an intricate manner to attain a set of functionalities. As the requirement of the software becomes more complex, the number of variables that needs to be kept track of increases; the logic of the computation the programmer needs to maintain the states becomes more complicated. Further, it is often that the variables are inter-dependent of each other. For instance, updating a variable might require updating another; how a variable should be updated might depend on another variable. As the number of variables increases, so is the number of relationships between the variables that the programer has to keep track of. Failure to correctly maintain the variables and the relationship between them most likely will lead to bugs. Further, real world software rarely remains static. This property, is again different from what you have experienced in introductory programming module, where once the instructors release a programming homework, they rarely go back and change the requirement. In the real world, software evolves over time -- new features are added, business rules changes, better algorithms are deployed. The code needs to be updated accordingly -- adding new variables and new computation; changing how variables are updated or are dependent on each other. Updating the code of an already-complex software to keep up with the requirement, if not managed properly, can lead to bugs. Real world software is often the product of teamwork from multiple programmers, where the software development process is unlike what you have experienced in your introductory programming module, where you solve your homework individually. When multiple programmers work together, the interdependency between the states need to be communicated and handled properly and consistently across the programmers. One programmer's modification to the code should not introduce bugs into another programmer's code. Since software envolves over time, the notion of \"multiple programmers\" actually applies even to software developed by a single lone programmer across time. Changing one's code should not introduce new bugs to other parts of the code that is written some time ago.","title":"Taming Complexity in Software Development"},{"location":"00-overview.html#strategies-to-tame-complexity","text":"","title":"Strategies to Tame Complexity"},{"location":"00-overview.html#good-software-development-practices","text":"If you are taught properly in your introductory programming modules, you should already be familiar with some of the good programming practices that help to tame the complexity and reduce the chances of bugs. These practices include Comment your code: Commenting your code provides in situ communication between you and other programmers on the team, as well as between you and your future self, on the non-obvious purpose of the states and the relationships between the states. Such comments help to enhance the understanding of what the code is doing and to remind whoever is updating to code to modify appropriately when the requirement changes. Use a coding convention: Adhering to a coding convention helps improves code readability, reducing the cognitive barrier when one programmer reads another programmer's code and allowing the reader to understand the code more easily and thoroughly. CS2030/S will continue to enforce these good programming practices.","title":"Good Software Development Practices"},{"location":"00-overview.html#functions","text":"You should also be taught to always break you code down into functions, each one performs a simple, specific, task. The functions can then be composed to solve larger and more complex tasks. Functions is an important programming structure in taming code complexity, it allows programmers to (i) compartmentalize computation and its effects, reducing the amount of interactions to a few well defined ones (through arguments and return values); (ii) hide the implementation details so that they can be changed later without affecting other parts of the code; (iii) reuse computations and thus write code that is more succinct and easier to understand/change. In CS2030/S, you will not only continue to break your computation into functions, but we will kick it up several notches. A major part of CS2030/S is to introduce you to more programming paradigms and language tools that allow you to compartmentalize computations, hide details, and reduce repetition.","title":"Functions"},{"location":"00-overview.html#the-abstraction-principle","text":"The last point above about why it is important to code in small, reusable functions, follows what is called the Abstraction Principle 1 . The principle states that: \"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\" This principle is something that we will visit over and over again in CS2030/S, applying it to different varying parts of a program. In the case of functions, the \"varying parts\" are the values on which we wish to perform the computation on. We will also apply this principle to (i) types, abstracting them out as generic types or subtypes, and (ii) to sub-computation, abstracting them out as higher-order functions. These concepts: generics, subtypes, higher-order functions, underlies most of the content of CS2030/S.","title":"The Abstraction Principle"},{"location":"00-overview.html#erecting-an-abstraction-barrier","text":"Another important strategy for taming complexity is the abstraction barrier . Let's separate the role of a programmer into two, in the context of writing functions: the implementer , who implements the function, and a client , who calls the function. The implementer should compartmentalize the internal states and the implementation of the function, hiding them behind the abstraction barrier, only exposing the parameters and return values as the only communication gateways across the barrier. The abstraction barrier is something that we will refer to repeatedly in CS2030/S as well. We will see how we maintain this barrier not only in the context of functions, but also states and computations on these states together, by encapsulating them as objects , and hiding details from the client through access modifiers . These ideas form two of the core principles of object-oriented programming : encapsulation and abstraction .","title":"Erecting an Abstraction Barrier"},{"location":"00-overview.html#code-for-change","text":"The abstraction barrier, if erected and maintained properly, reduces code complexity. It, however, also reduces the flexibility as the software evolves. If the client wishes to modify the computation protected by the abstraction barrier, it will need the help of the implementer. In CS2030/S, we will see two ways we can modify the computation behind the abstraction barrier, without changing the code behind the barrier . First, we will introduce the concept of inheritence and polymorphism , the other two core principles of object-oriented programming. These object-oriented mechanisms allow programmers to easily extend or modify the behavior of existing code. Second, we will introduce closure , an abstraction to a computation and its environment, that we can pass into the functions behind the abstraction barrier to perform a computation. The second idea, if carried to the extreme in terms of flexibility, leads to the concept of monad in functional programming paradigm. A monad is a computational structure that allows objects to be composed and manipulated in a succint and powerful way.","title":"Code for Change"},{"location":"00-overview.html#types","text":"Allowing a programmer to change the behavior of the existing code without changing the code could lead to more bugs, if not managed properly. To prevent this, both the programming language system, and the programmers, have to adhere to certain rules when extending or modifying the behavior of the existing code. Java and many other typed languages have type systems -- a set of rules that govern how variables, expressions, and functions interact with each other. You will learn about subtyping and the Liskov Substitution Principle, two notions that are important to constraining how inheritance and polymorphism should be used to avoid bugs. A type system is also an important tools to reduce the complexity of software development. By constraining the interactions among the variables, expressions, functions, it reduces the possible interdependence between these programming constructs. Furthermore, any attempt by programmers to break the constraint can be caught automatically. By utilizing the type system properly, we can detect potential bugs before it manifests itself. A reason CS2030/S chooses to use Java is due to its type system. CS2030/S will introduce the concept of types, subtypes, compile-time vs. run-time types, variants of types, generic types, and type inferences, in the context of Java. We will see how we can define our own types (using classes and interfaces ) and define relationships between them. We will see how we can define generic types and generic functions that takes in types as parameters. These concepts are applicable to many other programming languages.","title":"Types"},{"location":"00-overview.html#eliminating-side-effects","text":"We have discussed how functions can compartmentalize computations and isolate its complexity to within its body. For this approach to be effective, the function must not have any side effect -- such as updating a variable that is not within the function. Such functions, called pure functions , is one of the key principles of the functional programming paradigm, and is something that we will explore to kick off the section on functional paradigm in CS2030/S. A related idea in object-oriented programming we will cover in CS2030/S is immutability -- once we create an object, the object cannot be changed. In order to update an object, we need to create a new one. With immutability and pure functions, we can guarantee that the same function invoked on the same objects will always return the same value. This certainty can help in understanding and reasoning about the code behavior. This principle is formulated by Benjamin C. Pierce in his book \"Types and Programming Languages.\" \u21a9","title":"Eliminating Side Effects"},{"location":"01-compiler.html","text":"Unit 1: Program and Compiler After reading this unit, students should: recap some fundamental programming concepts, including the concept of a program, a programming language, a compiler, and an interpreter be aware of two modes of running a Java program (compiled vs. interpreted) be aware that compile-time errors are better than run-time errors, but the compiler cannot always detect errors during compile time Software Program A software program is a collection of data variables and instructions on how to modify these variables. To dictate these instructions to the computer, programmers usually write down the instructions using a programming language, expressing their instructions in code that are made up of keywords, symbols, and names. A programming language is a formal language that helps programmers specify precisely what the instructions are at a higher level of abstraction (i.e., at a higher conceptual level) so that a programmer only needs to write a few lines of code to give complex instructions to the computer. Compiled vs. Interpreted Programs The processing unit of a computer can only accept and understand instructions written in machine code. A program, written in a higher-level programming language, therefore needs to be translated into machine code before execution. There are different approaches to how such translations can be done. The first approach uses a compiler -- a software tool that reads in the entire program written in a higher-level programming language and translates it into machine code. The machine code is then saved into an executable file, which can be executed later. clang , a C/C++ compiler, is an example. The second approach uses an interpreter -- software that reads in the program one statement at a time interprets what the statement means, and executes its directly. This is how Python and Javascript programs are executed. Modern programming systems for executing programs are, however, more sophisticated. V8, for instance, is an open-source engine that executes Javascript, and it contains both an interpreter that first interprets a Javascript into bytecode (an intermediate, low-level representation). A just-in-time compiler then reads in the bytecode and generates machine code dynamically at runtime with optimized performance. Java programs, on the other hand, can be executed in two ways. The Java program can first be compiled into bytecode. During execution, the bytecode is interpreted and compiled on-the-fly by the Java Virtual Machine (JVM) into machine code. The Java program can also be interpreted by the Java interpreter. Since CS2030/S uses Java, let's look at the two approaches in more detail (without worrying about how to write a single line of Java first). Compiling and Running Java Programs Suppose we have a Java program called Hello.java . To compile the program, we type 1 1 $ javac Hello.java into the command line. javac is the Java compiler. This step will either lead to the bytecode called Hello.class being created or spew out some errors. Assuming that there is no error, we can now run 1 $ java Hello to invoke the JVM java and execute the bytecode contains in Hello.class . Beginners tend to confuse between javac and java , and whether to add the extension .java or .class when compiling and executing a Java program. Do take note and refer back here if needed 2 . Interpreting a Java program Java (version 8 or later) comes with an interpreter called jshell that can read in Java statements, evaluate them, and print the results 3 . jshell is useful for learning and experimenting about Java. To run jshell in interactive mode, we type 1 $ jshell on the command line, which causes an interactive prompt to appear: 1 2 3 4 5 $ jshell | Welcome to JShell -- Version 11.0.2 | For an introduction type: /help intro jshell> We can now type in Java code on jshell> . Alternatively, we can also include all the Java statements that we want jshell to run in a file and pass it into jshell 1 $ jshell Hello.jsh While jshell is a convenient way to test things out and play with new Java concepts as we learn, do keep in mind that jshell combined both compilation and run-time into a single step. The error spewed out by jshell could be either compile-time error or run-time error, and this could be confusing to beginners who try to distinguish between the two phases of program execution. Compiler The compiler does more than just translating source code into machine code or bytecode. The compiler also needs to parse the source code written and check if it follows the precise specification of the programming language (called grammar ) used, and produces a syntax error if the grammar is violated. It therefore can detect any syntax error before the program is run. In contrast, an interpreter may only detect the syntax error when it executes a particular line of code (e.g., when there is a typo in the name of a function) and so syntax errors are uncovered only during runtime. It is much better for a programmer to detect any error in its code during compilation -- since this is the phase when the program is still being developed and under the control of the programmer. Runtime error, on the other hand, might occur when the customers are running the program, and so are much less desirable. As such, we try to detect errors as much as possible during compilation. The compiler is a powerful friend for any programmer if used properly. The power of the compiler, however, is limited. A compiler can only read and analyze the source code without actually running it. Without running the program, the compiler cannot always tell if a particular statement in the source code will ever be executed; it cannot always tell what values a variable will take. To deal with this, the compiler can either be conservative , and report an error as long as there is a possibility that a particular statement is incorrect; or, the compiler can be more permissive , reporting an error only if there is no possiblity that a particular statement is correct. If there is a possibility that a particular statement is correct, it does not throw an error, but rely on the programmer to do the right thing. We will further contrast these two behaviors later in this module. The $ represents the command prompt in a shell and you do not need to type this. \u21a9 To add to the confusion, Java 11 introduces a shortcut where we can run java Hello.java directly. This command causes Hello.java to be compiled and executed in a single step. We won't do this in CS2030/S (i) to avoid confusion and (ii) to show you the steps explicitly. \u21a9 Such a program is called REPL (Read-Evaluate-Print in a Loop) for short. \u21a9","title":"1. Program and Compiler"},{"location":"01-compiler.html#unit-1-program-and-compiler","text":"After reading this unit, students should: recap some fundamental programming concepts, including the concept of a program, a programming language, a compiler, and an interpreter be aware of two modes of running a Java program (compiled vs. interpreted) be aware that compile-time errors are better than run-time errors, but the compiler cannot always detect errors during compile time","title":"Unit 1: Program and Compiler"},{"location":"01-compiler.html#software-program","text":"A software program is a collection of data variables and instructions on how to modify these variables. To dictate these instructions to the computer, programmers usually write down the instructions using a programming language, expressing their instructions in code that are made up of keywords, symbols, and names. A programming language is a formal language that helps programmers specify precisely what the instructions are at a higher level of abstraction (i.e., at a higher conceptual level) so that a programmer only needs to write a few lines of code to give complex instructions to the computer.","title":"Software Program"},{"location":"01-compiler.html#compiled-vs-interpreted-programs","text":"The processing unit of a computer can only accept and understand instructions written in machine code. A program, written in a higher-level programming language, therefore needs to be translated into machine code before execution. There are different approaches to how such translations can be done. The first approach uses a compiler -- a software tool that reads in the entire program written in a higher-level programming language and translates it into machine code. The machine code is then saved into an executable file, which can be executed later. clang , a C/C++ compiler, is an example. The second approach uses an interpreter -- software that reads in the program one statement at a time interprets what the statement means, and executes its directly. This is how Python and Javascript programs are executed. Modern programming systems for executing programs are, however, more sophisticated. V8, for instance, is an open-source engine that executes Javascript, and it contains both an interpreter that first interprets a Javascript into bytecode (an intermediate, low-level representation). A just-in-time compiler then reads in the bytecode and generates machine code dynamically at runtime with optimized performance. Java programs, on the other hand, can be executed in two ways. The Java program can first be compiled into bytecode. During execution, the bytecode is interpreted and compiled on-the-fly by the Java Virtual Machine (JVM) into machine code. The Java program can also be interpreted by the Java interpreter. Since CS2030/S uses Java, let's look at the two approaches in more detail (without worrying about how to write a single line of Java first).","title":"Compiled vs. Interpreted Programs"},{"location":"01-compiler.html#compiling-and-running-java-programs","text":"Suppose we have a Java program called Hello.java . To compile the program, we type 1 1 $ javac Hello.java into the command line. javac is the Java compiler. This step will either lead to the bytecode called Hello.class being created or spew out some errors. Assuming that there is no error, we can now run 1 $ java Hello to invoke the JVM java and execute the bytecode contains in Hello.class . Beginners tend to confuse between javac and java , and whether to add the extension .java or .class when compiling and executing a Java program. Do take note and refer back here if needed 2 .","title":"Compiling and Running Java Programs"},{"location":"01-compiler.html#interpreting-a-java-program","text":"Java (version 8 or later) comes with an interpreter called jshell that can read in Java statements, evaluate them, and print the results 3 . jshell is useful for learning and experimenting about Java. To run jshell in interactive mode, we type 1 $ jshell on the command line, which causes an interactive prompt to appear: 1 2 3 4 5 $ jshell | Welcome to JShell -- Version 11.0.2 | For an introduction type: /help intro jshell> We can now type in Java code on jshell> . Alternatively, we can also include all the Java statements that we want jshell to run in a file and pass it into jshell 1 $ jshell Hello.jsh While jshell is a convenient way to test things out and play with new Java concepts as we learn, do keep in mind that jshell combined both compilation and run-time into a single step. The error spewed out by jshell could be either compile-time error or run-time error, and this could be confusing to beginners who try to distinguish between the two phases of program execution.","title":"Interpreting a Java program"},{"location":"01-compiler.html#compiler","text":"The compiler does more than just translating source code into machine code or bytecode. The compiler also needs to parse the source code written and check if it follows the precise specification of the programming language (called grammar ) used, and produces a syntax error if the grammar is violated. It therefore can detect any syntax error before the program is run. In contrast, an interpreter may only detect the syntax error when it executes a particular line of code (e.g., when there is a typo in the name of a function) and so syntax errors are uncovered only during runtime. It is much better for a programmer to detect any error in its code during compilation -- since this is the phase when the program is still being developed and under the control of the programmer. Runtime error, on the other hand, might occur when the customers are running the program, and so are much less desirable. As such, we try to detect errors as much as possible during compilation. The compiler is a powerful friend for any programmer if used properly. The power of the compiler, however, is limited. A compiler can only read and analyze the source code without actually running it. Without running the program, the compiler cannot always tell if a particular statement in the source code will ever be executed; it cannot always tell what values a variable will take. To deal with this, the compiler can either be conservative , and report an error as long as there is a possibility that a particular statement is incorrect; or, the compiler can be more permissive , reporting an error only if there is no possiblity that a particular statement is correct. If there is a possibility that a particular statement is correct, it does not throw an error, but rely on the programmer to do the right thing. We will further contrast these two behaviors later in this module. The $ represents the command prompt in a shell and you do not need to type this. \u21a9 To add to the confusion, Java 11 introduces a shortcut where we can run java Hello.java directly. This command causes Hello.java to be compiled and executed in a single step. We won't do this in CS2030/S (i) to avoid confusion and (ii) to show you the steps explicitly. \u21a9 Such a program is called REPL (Read-Evaluate-Print in a Loop) for short. \u21a9","title":"Compiler"},{"location":"02-type.html","text":"Unit 2: Variable and Type After this unit, students should appreciate the concept of variables as an abstraction understand the concept of types and subtypes contrast between statically typed language vs. dynamically typed language contrast between strongly typed language vs. weakly typed language be familiar with Java variables and primitive types understand widening type conversion in the context of variable assignments and how subtyping dictates whether the type conversion is allowed. Data Abstraction: Variable One of the important abstractions that are provided by a programming language is variable . Data are stored in some location in computer memory. But we should not be referring to the memory location all the time. First, referring to something like 0xFA49130E is not user-friendly; Second, the location may change. A variable is an abstraction that allows us to give a user-friendly name to a piece of data in memory. We use the variable name whenever we want to access the value in that location, and pointer to the variable or reference to the variable whenever we want to refer to the address of the location. Type As programs get more complex, the number of variables that the programmer needs to keep track of increases. These variables might be an abstraction over different types of data: some variables might refer to a number, some to a string, some to a list of numbers, etc. Not all operations are meaningful over all types of data. To help mitigate the complexity, we can assign a type to a variable. The type communicates to the readers what data type the variable is an abstraction over, and to the compiler/interpreter what operations are valid on this variable and how the operation behaves. In lower-level programming languages like C, the type also inform the compiler how the bit representing the variable should be interpreted. As an example of how types can affect how an operation behaves, let's consider Python. Suppose we have two variables x and y , storing the values 4 and 5 respectively and we run print x + y . If x and y are both strings, you would get 45 ; if x and y are integers, you would get 9 ; if 4 is an integer and 5 is a string, you would get an error. In the last instance above, you see that assigning a type to each variable helps to keep the program meaningful, as the operation + is not defined over an integer and a string in Python. Java and Javascript, however, would happily convert 4 into a string for you, and return 45 . Dynamic vs. Static Type Python and Javascript are examples of dynamically typed programming languages. The same variable can hold values of different types, and checking if the right type is used is done during the execution of the program. Note that, the type is associated with the values , and the type of the variable changes depending on the value it holds. For example, we can do the following: 1 2 i = 4 // i is an integer i = \"5\" // ok, i is now a string Java, on the other hand, is a statically typed language. We need to declare every variable we use in the program and specify its type. A variable can only hold values of the same type as the type of the variable, so we can't assign, for instance, a string to a variable of type int . Once a variable is assigned a type, its type cannot be changed. 1 2 3 int i ; // declare a variable i = 4 ; // ok i = \"5\" ; // error, cannot assign a string to an `int` The type that a variable is assigned with when we declare the variable is also known as the compile-time type . During the compilation, this is the only type that the compiler is aware of. The compiler will check if the compile-time type matches when it parses the variables, expressions, values, and function calls, and throw an error if there is a type mismatch. This type-checking step helps to catch errors in the code early. Strong Typing vs. Weak Typing A type system of a programming language is a set of rules that govern how the types can interact with each other. A programming language can be strongly typed or weakly typed. There are no formal definitions of \"strong\" vs. \"weak\" typing of a programming language, and there is a spectrum of \"strength\" between the typing discipline of a language. Generally, a strongly typed programming language enforces strict rules in its type system, to ensure type safety , i.e., to catch type errors during compile time rather than leaving it to runtime. On the other hand, a weakly typed (or loosely typed ) programming language is more permissive in terms of typing checking. C is an example of a static, weakly, type language. In C, the following is possible: 1 2 3 int i ; // declare a variable i = 4 ; // ok i = ( int ) \"5\" ; // you want to treat a string, ok, as you wish. The last line forces the C compiler to treat the string as an integer, through typecasting. The C compiler allows it. In contrast, if we try the following in Java: 1 2 3 int i ; // declare a variable i = 4 ; // ok i = ( int ) \"5\" ; // error we will get the following error message: 1 | incompatible types: java.lang.String cannot be converted to int because the compiler enforces a stricter rule and allows typecasting only if it makes sense. Primitive Types in Java We now switch our focus to Java, particularly to the types supported. There are two categories of types in Java, the primitive types and the reference types . We will first look at primitive types in this unit. Primitive types are types that holds numeric values (integers, floating-point numbers) as well as boolean values ( true and false ). For storing integral values, Java provides four types, byte , short , int , and long , for storing 8-bit, 16-bit, 32-bit, 64-bit signed integers respectively. The type char stores 16-bit unsigned integers representing UTF-16 Unicode characters. For storing floating-point values, Java provides two types, float and double , for 16-bit and 32-bit floating-point numbers. Unlike reference types, which we will see later, primitive type variables never share their value with each other, i.e., if we have: 1 2 3 int i = 1000; int j = i; i = i + 1; i and j each store a copy of the value 1000 after Line 2. Changing i on Line 3 does not change the content of j . Subtypes An important concept that we will visit repeatedly in CS2030/S is the concept of subtypes. Let \\(S\\) and \\(T\\) be two types. We say that \\(T\\) is a subtype of \\(S\\) if a piece of code written for variables of type \\(S\\) can also safely be used on variables of type \\(T\\) . We use the notation \\(T <: S\\) or \\(S :> T\\) to denote that \\(T\\) is subtype of \\(S\\) . The subtype relationship is transitive, i.e., if \\(S <: T\\) and \\(T <: U\\) , then \\(S <: U\\) . It is also reflexive, for any type \\(S\\) , \\(S <: S\\) . We also use the term supertype to denote the reverse relationship: if \\(T\\) is a subtype of \\(S\\) , then \\(S\\) is a supertype of \\(T\\) . Subtyping Between Java Primitive Types Consider the range of values that the primitive types can take, Java defines the following subtyping relationship: byte <: short <: int <: long <: float <: double char <: int Valid subtype relationship is part of what the Java compiler checks for when it compiles. Consider the following example: 1 2 3 4 double d = 5.0 ; int i = 5 ; d = i ; i = d ; // error Line 4 above would lead to an error: 1 | incompatible types: possible lossy conversion from double to int but Line 3 is OK. This example shows how subtyping applies to type checking. Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S <: T\\) . This step is called widening type conversion . Additional Readings Java Tutorial: Primitive Data Types and other Language Basics","title":"2. Variable and Type"},{"location":"02-type.html#unit-2-variable-and-type","text":"After this unit, students should appreciate the concept of variables as an abstraction understand the concept of types and subtypes contrast between statically typed language vs. dynamically typed language contrast between strongly typed language vs. weakly typed language be familiar with Java variables and primitive types understand widening type conversion in the context of variable assignments and how subtyping dictates whether the type conversion is allowed.","title":"Unit 2: Variable and Type"},{"location":"02-type.html#data-abstraction-variable","text":"One of the important abstractions that are provided by a programming language is variable . Data are stored in some location in computer memory. But we should not be referring to the memory location all the time. First, referring to something like 0xFA49130E is not user-friendly; Second, the location may change. A variable is an abstraction that allows us to give a user-friendly name to a piece of data in memory. We use the variable name whenever we want to access the value in that location, and pointer to the variable or reference to the variable whenever we want to refer to the address of the location.","title":"Data Abstraction: Variable"},{"location":"02-type.html#type","text":"As programs get more complex, the number of variables that the programmer needs to keep track of increases. These variables might be an abstraction over different types of data: some variables might refer to a number, some to a string, some to a list of numbers, etc. Not all operations are meaningful over all types of data. To help mitigate the complexity, we can assign a type to a variable. The type communicates to the readers what data type the variable is an abstraction over, and to the compiler/interpreter what operations are valid on this variable and how the operation behaves. In lower-level programming languages like C, the type also inform the compiler how the bit representing the variable should be interpreted. As an example of how types can affect how an operation behaves, let's consider Python. Suppose we have two variables x and y , storing the values 4 and 5 respectively and we run print x + y . If x and y are both strings, you would get 45 ; if x and y are integers, you would get 9 ; if 4 is an integer and 5 is a string, you would get an error. In the last instance above, you see that assigning a type to each variable helps to keep the program meaningful, as the operation + is not defined over an integer and a string in Python. Java and Javascript, however, would happily convert 4 into a string for you, and return 45 .","title":"Type"},{"location":"02-type.html#dynamic-vs-static-type","text":"Python and Javascript are examples of dynamically typed programming languages. The same variable can hold values of different types, and checking if the right type is used is done during the execution of the program. Note that, the type is associated with the values , and the type of the variable changes depending on the value it holds. For example, we can do the following: 1 2 i = 4 // i is an integer i = \"5\" // ok, i is now a string Java, on the other hand, is a statically typed language. We need to declare every variable we use in the program and specify its type. A variable can only hold values of the same type as the type of the variable, so we can't assign, for instance, a string to a variable of type int . Once a variable is assigned a type, its type cannot be changed. 1 2 3 int i ; // declare a variable i = 4 ; // ok i = \"5\" ; // error, cannot assign a string to an `int` The type that a variable is assigned with when we declare the variable is also known as the compile-time type . During the compilation, this is the only type that the compiler is aware of. The compiler will check if the compile-time type matches when it parses the variables, expressions, values, and function calls, and throw an error if there is a type mismatch. This type-checking step helps to catch errors in the code early.","title":"Dynamic vs. Static Type"},{"location":"02-type.html#strong-typing-vs-weak-typing","text":"A type system of a programming language is a set of rules that govern how the types can interact with each other. A programming language can be strongly typed or weakly typed. There are no formal definitions of \"strong\" vs. \"weak\" typing of a programming language, and there is a spectrum of \"strength\" between the typing discipline of a language. Generally, a strongly typed programming language enforces strict rules in its type system, to ensure type safety , i.e., to catch type errors during compile time rather than leaving it to runtime. On the other hand, a weakly typed (or loosely typed ) programming language is more permissive in terms of typing checking. C is an example of a static, weakly, type language. In C, the following is possible: 1 2 3 int i ; // declare a variable i = 4 ; // ok i = ( int ) \"5\" ; // you want to treat a string, ok, as you wish. The last line forces the C compiler to treat the string as an integer, through typecasting. The C compiler allows it. In contrast, if we try the following in Java: 1 2 3 int i ; // declare a variable i = 4 ; // ok i = ( int ) \"5\" ; // error we will get the following error message: 1 | incompatible types: java.lang.String cannot be converted to int because the compiler enforces a stricter rule and allows typecasting only if it makes sense.","title":"Strong Typing vs. Weak Typing"},{"location":"02-type.html#primitive-types-in-java","text":"We now switch our focus to Java, particularly to the types supported. There are two categories of types in Java, the primitive types and the reference types . We will first look at primitive types in this unit. Primitive types are types that holds numeric values (integers, floating-point numbers) as well as boolean values ( true and false ). For storing integral values, Java provides four types, byte , short , int , and long , for storing 8-bit, 16-bit, 32-bit, 64-bit signed integers respectively. The type char stores 16-bit unsigned integers representing UTF-16 Unicode characters. For storing floating-point values, Java provides two types, float and double , for 16-bit and 32-bit floating-point numbers. Unlike reference types, which we will see later, primitive type variables never share their value with each other, i.e., if we have: 1 2 3 int i = 1000; int j = i; i = i + 1; i and j each store a copy of the value 1000 after Line 2. Changing i on Line 3 does not change the content of j .","title":"Primitive Types in Java"},{"location":"02-type.html#subtypes","text":"An important concept that we will visit repeatedly in CS2030/S is the concept of subtypes. Let \\(S\\) and \\(T\\) be two types. We say that \\(T\\) is a subtype of \\(S\\) if a piece of code written for variables of type \\(S\\) can also safely be used on variables of type \\(T\\) . We use the notation \\(T <: S\\) or \\(S :> T\\) to denote that \\(T\\) is subtype of \\(S\\) . The subtype relationship is transitive, i.e., if \\(S <: T\\) and \\(T <: U\\) , then \\(S <: U\\) . It is also reflexive, for any type \\(S\\) , \\(S <: S\\) . We also use the term supertype to denote the reverse relationship: if \\(T\\) is a subtype of \\(S\\) , then \\(S\\) is a supertype of \\(T\\) .","title":"Subtypes"},{"location":"02-type.html#subtyping-between-java-primitive-types","text":"Consider the range of values that the primitive types can take, Java defines the following subtyping relationship: byte <: short <: int <: long <: float <: double char <: int Valid subtype relationship is part of what the Java compiler checks for when it compiles. Consider the following example: 1 2 3 4 double d = 5.0 ; int i = 5 ; d = i ; i = d ; // error Line 4 above would lead to an error: 1 | incompatible types: possible lossy conversion from double to int but Line 3 is OK. This example shows how subtyping applies to type checking. Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S <: T\\) . This step is called widening type conversion .","title":"Subtyping Between Java Primitive Types"},{"location":"02-type.html#additional-readings","text":"Java Tutorial: Primitive Data Types and other Language Basics","title":"Additional Readings"},{"location":"03-function.html","text":"Unit 3: Functions After reading this unit, students should understand the importance of function as a programming constructor and how it helps to reduce complexity and mitigate bugs. be aware of two different roles a programmer can play: the implementer and the client understand the concept of abstraction barrier as a wall between the client and the implementer, including in the context of a function. Function as an Abstraction over Computation Another important abstraction provided by a programming language is function (or procedure ). This abstraction allows programmers to group a set of instructions and give it a name. The named set of instructions may take one or more variables as input parameters, and return one or more values. Like all other abstractions, defining functions allow us to think at a higher conceptual level. By composing functions at increasingly higher level of abstractions, we can build programs with increasing level of complexity. Functions help us deal with complexity in a few ways: Functions allow programmers to compartmentalize computation and its effects. We can isolate the complexity to within its body: the intermediate variables exists only as local variables that has no effect outside of the function. A function only interacts with the rest of the code through its parameters and return value, and so, reduces the dependencies between variables to these well-defined interactions. Such compartmentalization reduces the complexity of code. Functions allow programmers to hide how a task is performed. The caller of the function only needs to worry about what the function do. By hiding the details of how , we gain two weapons against code complexity. First, we reduce the amount of information that we need to communicate among programmers. A fellow programmer only needs to read the documentation to understand what the parameters are for, what the return values are. There is no need for a fellow programmer to know about the intermediate variables or the internal computation used to implement the functions. Second, as the design and requirement evolve, the implementation of a function may change. But, as long as the parameters and the return value of a function remains the same, the caller of the function does not have to update the code accordingly. Reducing the needs to change as the software evolves reduces the chances of introducing bugs accordingly. Functions allows us to reduce repetition in our code through code reuse . If we have the same computation that we need to perform repeatedly on different values , we can construct these computation as functions, replacing the values with parameters, and pass in the values as arguments to the function. This approach reduces the amount of boiler-plate code and has two major benefits in reducing code complexity and bugs. First, it makes the code more succint, and therefore easier to read and understanding. Second, it reduces the number of places that we need to modify as the software evolves, and therefore, decreases the chance of introducing new bugs. Abstraction Barrier We can imagine an abstraction barrier between the code that calls a function and the code that defines the function body. Above the barrier, the concern is about using the function to perform a task, while below the barrier, the concern is about how to perform the task. While many of you are used to writing a program solo, in practice, you rarely write a program with contributions from a single person. The abstraction barrier separates the role of the programmer into two: (i) an implementer , who provides the implementation of the function, and (ii) a client , which uses the function to perform the task. Part of the aim in CS2030/S is to switch your mindset into thinking in terms of these two roles. The abstraction barrier thus enforces a separation of concerns between the two roles. The concept of abstraction barrier applies not only to a function, but it can be applied to different level of abstractions as well. We will see how it is use for a higher-level of abstraction in the next unit.","title":"3. Functions"},{"location":"03-function.html#unit-3-functions","text":"After reading this unit, students should understand the importance of function as a programming constructor and how it helps to reduce complexity and mitigate bugs. be aware of two different roles a programmer can play: the implementer and the client understand the concept of abstraction barrier as a wall between the client and the implementer, including in the context of a function.","title":"Unit 3: Functions"},{"location":"03-function.html#function-as-an-abstraction-over-computation","text":"Another important abstraction provided by a programming language is function (or procedure ). This abstraction allows programmers to group a set of instructions and give it a name. The named set of instructions may take one or more variables as input parameters, and return one or more values. Like all other abstractions, defining functions allow us to think at a higher conceptual level. By composing functions at increasingly higher level of abstractions, we can build programs with increasing level of complexity. Functions help us deal with complexity in a few ways: Functions allow programmers to compartmentalize computation and its effects. We can isolate the complexity to within its body: the intermediate variables exists only as local variables that has no effect outside of the function. A function only interacts with the rest of the code through its parameters and return value, and so, reduces the dependencies between variables to these well-defined interactions. Such compartmentalization reduces the complexity of code. Functions allow programmers to hide how a task is performed. The caller of the function only needs to worry about what the function do. By hiding the details of how , we gain two weapons against code complexity. First, we reduce the amount of information that we need to communicate among programmers. A fellow programmer only needs to read the documentation to understand what the parameters are for, what the return values are. There is no need for a fellow programmer to know about the intermediate variables or the internal computation used to implement the functions. Second, as the design and requirement evolve, the implementation of a function may change. But, as long as the parameters and the return value of a function remains the same, the caller of the function does not have to update the code accordingly. Reducing the needs to change as the software evolves reduces the chances of introducing bugs accordingly. Functions allows us to reduce repetition in our code through code reuse . If we have the same computation that we need to perform repeatedly on different values , we can construct these computation as functions, replacing the values with parameters, and pass in the values as arguments to the function. This approach reduces the amount of boiler-plate code and has two major benefits in reducing code complexity and bugs. First, it makes the code more succint, and therefore easier to read and understanding. Second, it reduces the number of places that we need to modify as the software evolves, and therefore, decreases the chance of introducing new bugs.","title":"Function as an Abstraction over Computation"},{"location":"03-function.html#abstraction-barrier","text":"We can imagine an abstraction barrier between the code that calls a function and the code that defines the function body. Above the barrier, the concern is about using the function to perform a task, while below the barrier, the concern is about how to perform the task. While many of you are used to writing a program solo, in practice, you rarely write a program with contributions from a single person. The abstraction barrier separates the role of the programmer into two: (i) an implementer , who provides the implementation of the function, and (ii) a client , which uses the function to perform the task. Part of the aim in CS2030/S is to switch your mindset into thinking in terms of these two roles. The abstraction barrier thus enforces a separation of concerns between the two roles. The concept of abstraction barrier applies not only to a function, but it can be applied to different level of abstractions as well. We will see how it is use for a higher-level of abstraction in the next unit.","title":"Abstraction Barrier"},{"location":"04-encapsulation.html","text":"Unit 4: Encapsulation After reading this unit, students should understand composite data type as a even-higher level abstractions over variables understand encapsulation as an object-oriented (OO) principle understand the meaning of class, object, fields, methods, in the context of OO programming be able to define a class and instantiate one as an object in Java appreciate OO as a natural way to model the real world in programs understand reference types in Java and its difference from the primitive types Abstraction: Composite Data Type Just like functions allow programmers to group instructions, give it a name, and refer to it later, a composite data type allows programmers to group primitive types together, give it a name (a new type), and refer to it later. This is another powerful abstraction in programming languages that help us to think at a higher conceptual level without worrying about the details. Commonly used examples are mathematical objects such as complex numbers, 2D data points, multi-dimensional vectors, circles, etc, or everyday objects such as a person, a product, etc. Defining composite data type allows programmers to abstract away (and be separated from the concern of) how a complex data type is represented. For instance, a circle on a 2D plane can be represented by the center ( x , y ) and its radius r , or it can be represented by the top left corner ( x , y ) and the width w of the bounding square. In C, we build a composite data type with struct . For example, 1 2 3 4 typedef struct { double x , y ; // (x,y) coordinate of the center. double r ; // radius } circle ; Once we have the struct defined, we are not completely shielded from its representation, until we write a set of functions that operates on the circle composite type. For instance, 1 2 3 double circle_area ( circle c ) { ... }; bool circle_contains_point ( circle c , double x , double y ) { ... }; : Implementing these functions requires knowledge of how a circle is represented. Once the set of functions that operates on and manipulates circles is available, we can use the circle type without worrying about the internal representation. If we decide to change the representation of a circle, then only the set of functions that operates on a circle type need to be changed, but not the code that uses circles to do other things. Abstraction: Class and Object (or, Encapsulation) We can further bundle the composite data type and its associated functions together in another abstraction, called a class . A class is a data type with a group of functions associated with it. We call the functions as methods and the data in the class as fields (or members , or states , or attributes 1 ). A well-designed class maintains the abstraction barrier, properly wraps the barrier around the internal representation and implementation, and exposes just the right method interface for others to use. The concept of keeping all the data and functions operating on the data related to a composite data type together within an abstraction barrier is called encapsulation . Let's see how we can encapsulate the fields and methods associated together, using Circle as an example, in Java. 1 2 3 4 5 6 7 8 9 10 // Circle v0.1 class Circle { double x ; double y ; double r ; double getArea () { return 3.141592653589793 * r * r ; }; } The code above defines a new class using the keyword class , give it a name Circle 2 , followed by a block listing the member variables (with types) and the function definitions. Just like we can create variables of a given type, we can create objects of a given class. Objects are instances of a class, each allowing the same methods to be called, and each containing the same set of variables of the same types, but (possibly) storing different values. In Java, the keyword new creates an object of a given class. For instance, to create a Circle object, we can use 1 Circle c = new Circle(); To access the fields and the methods, we use the . notation. For example, object.field or object.method(..) . For instance, 1 2 c.r = 10; // set the radius to 10 c.getArea(); // return 314.1592653589793 Object-Oriented Programming A program written in an object-oriented language such as Java consists of classes, with one main class as the entry point. One can view a running object-oriented (or OO) program as something that instantiates objects of different classes and orchestrates their interactions with each other by calling each others' methods. One could argue that an object-oriented way of writing programs is much more natural, as it mirrors our world more closely. If we look around us, we see objects all around us, and each object has certain properties, exhibits certain behavior, and they allow certain actions. We interact with the objects through their interfaces, and we rarely need to know the internals of the objects we used every day (unless we try to repair them) 3 . To model a problem in an object-oriented manner, we typically model the nouns as classes and objects, the properties or relationships among the classes as fields, and the verbs or actions of the corresponding objects as methods. Reference Types in Java We mentioned in Unit 2 that there are two kinds of types in Java. You have been introduced to the primitive types. Everything else in Java is a reference type. The Circle class is an example of a reference type. Unlike primitive variables, which never share the value, a reference variable stores only the reference to the value, and therefore two reference variables can share the same value. For instance, 1 2 3 4 5 Circle c1 = new Circle(); Circle c2 = c1; System.out.println(c2.r); // print 0 c1.r = 10.0; System.out.println(c2.r); // print 10.0 The behavior above is due to the variables c1 and c2 referencing to the same Circle object in the memory. Therefore, changing the field r of c1 causes the field r of c2 to change as well. Further Readings Oracle's Java Tutorial on Classes and Objects Computer scientists just could not decide what to call this :( \u21a9 As a convention, we use Pascal case for class name and camel case for variable and method names in Java. \u21a9 This is a standard analogy in an OOP textbook. In practice, however, we often have to write programs that include abstract concepts with no tangible real-world analogy as classes. \u21a9","title":"4. Encapsultion"},{"location":"04-encapsulation.html#unit-4-encapsulation","text":"After reading this unit, students should understand composite data type as a even-higher level abstractions over variables understand encapsulation as an object-oriented (OO) principle understand the meaning of class, object, fields, methods, in the context of OO programming be able to define a class and instantiate one as an object in Java appreciate OO as a natural way to model the real world in programs understand reference types in Java and its difference from the primitive types","title":"Unit 4: Encapsulation"},{"location":"04-encapsulation.html#abstraction-composite-data-type","text":"Just like functions allow programmers to group instructions, give it a name, and refer to it later, a composite data type allows programmers to group primitive types together, give it a name (a new type), and refer to it later. This is another powerful abstraction in programming languages that help us to think at a higher conceptual level without worrying about the details. Commonly used examples are mathematical objects such as complex numbers, 2D data points, multi-dimensional vectors, circles, etc, or everyday objects such as a person, a product, etc. Defining composite data type allows programmers to abstract away (and be separated from the concern of) how a complex data type is represented. For instance, a circle on a 2D plane can be represented by the center ( x , y ) and its radius r , or it can be represented by the top left corner ( x , y ) and the width w of the bounding square. In C, we build a composite data type with struct . For example, 1 2 3 4 typedef struct { double x , y ; // (x,y) coordinate of the center. double r ; // radius } circle ; Once we have the struct defined, we are not completely shielded from its representation, until we write a set of functions that operates on the circle composite type. For instance, 1 2 3 double circle_area ( circle c ) { ... }; bool circle_contains_point ( circle c , double x , double y ) { ... }; : Implementing these functions requires knowledge of how a circle is represented. Once the set of functions that operates on and manipulates circles is available, we can use the circle type without worrying about the internal representation. If we decide to change the representation of a circle, then only the set of functions that operates on a circle type need to be changed, but not the code that uses circles to do other things.","title":"Abstraction: Composite Data Type"},{"location":"04-encapsulation.html#abstraction-class-and-object-or-encapsulation","text":"We can further bundle the composite data type and its associated functions together in another abstraction, called a class . A class is a data type with a group of functions associated with it. We call the functions as methods and the data in the class as fields (or members , or states , or attributes 1 ). A well-designed class maintains the abstraction barrier, properly wraps the barrier around the internal representation and implementation, and exposes just the right method interface for others to use. The concept of keeping all the data and functions operating on the data related to a composite data type together within an abstraction barrier is called encapsulation . Let's see how we can encapsulate the fields and methods associated together, using Circle as an example, in Java. 1 2 3 4 5 6 7 8 9 10 // Circle v0.1 class Circle { double x ; double y ; double r ; double getArea () { return 3.141592653589793 * r * r ; }; } The code above defines a new class using the keyword class , give it a name Circle 2 , followed by a block listing the member variables (with types) and the function definitions. Just like we can create variables of a given type, we can create objects of a given class. Objects are instances of a class, each allowing the same methods to be called, and each containing the same set of variables of the same types, but (possibly) storing different values. In Java, the keyword new creates an object of a given class. For instance, to create a Circle object, we can use 1 Circle c = new Circle(); To access the fields and the methods, we use the . notation. For example, object.field or object.method(..) . For instance, 1 2 c.r = 10; // set the radius to 10 c.getArea(); // return 314.1592653589793","title":"Abstraction: Class and Object (or, Encapsulation)"},{"location":"04-encapsulation.html#object-oriented-programming","text":"A program written in an object-oriented language such as Java consists of classes, with one main class as the entry point. One can view a running object-oriented (or OO) program as something that instantiates objects of different classes and orchestrates their interactions with each other by calling each others' methods. One could argue that an object-oriented way of writing programs is much more natural, as it mirrors our world more closely. If we look around us, we see objects all around us, and each object has certain properties, exhibits certain behavior, and they allow certain actions. We interact with the objects through their interfaces, and we rarely need to know the internals of the objects we used every day (unless we try to repair them) 3 . To model a problem in an object-oriented manner, we typically model the nouns as classes and objects, the properties or relationships among the classes as fields, and the verbs or actions of the corresponding objects as methods.","title":"Object-Oriented Programming"},{"location":"04-encapsulation.html#reference-types-in-java","text":"We mentioned in Unit 2 that there are two kinds of types in Java. You have been introduced to the primitive types. Everything else in Java is a reference type. The Circle class is an example of a reference type. Unlike primitive variables, which never share the value, a reference variable stores only the reference to the value, and therefore two reference variables can share the same value. For instance, 1 2 3 4 5 Circle c1 = new Circle(); Circle c2 = c1; System.out.println(c2.r); // print 0 c1.r = 10.0; System.out.println(c2.r); // print 10.0 The behavior above is due to the variables c1 and c2 referencing to the same Circle object in the memory. Therefore, changing the field r of c1 causes the field r of c2 to change as well.","title":"Reference Types in Java"},{"location":"04-encapsulation.html#further-readings","text":"Oracle's Java Tutorial on Classes and Objects Computer scientists just could not decide what to call this :( \u21a9 As a convention, we use Pascal case for class name and camel case for variable and method names in Java. \u21a9 This is a standard analogy in an OOP textbook. In practice, however, we often have to write programs that include abstract concepts with no tangible real-world analogy as classes. \u21a9","title":"Further Readings"},{"location":"05-infohiding.html","text":"Unit 5: Information Hiding After taking this unit, students should: understand the drawback of breaking the abstraction barrier understand the concept of information hiding to enforce the abstraction barrier understand how Java uses access modifiers to enforce information hiding understand what is a constructor and how to write one in Java Breaking the Abstraction Barrier In the ideal case, the code above the abstraction barrier would just call the provided interface to use the composite data type. There, however, may be cases where a programmer may intentionally or accidentally break the abstraction barrier. Consider the case of Circle above, where we modify the radius r directly with c.r = 10 . In doing so, we, as the client to Circle , make an explicit assumption of how Circle implements a circle. The implementation details have been leaked outside the abstraction barrier. Now, if the implementer wishes to change the representation, to say, store the diameter, instead. It would invalidate the code that the client has written! The client will have to carefully change all the code that makes the assumption, and modify accordingly, increasing the chances of introducing a bug. Data Hiding Many OO languages allow programmers to explicitly specify if a field or a method can be accessed from outside the abstraction barrier. Java, for instance, supports private and public access modifiers[^5]. A field or a method that is declared as private cannot be accessed from outside the class, and can only be accessed within the class. On the other hand, as you can guess, a public field or method can be accessed, modified, or invoked from outside the class. Such a mechanism to protect the abstraction barrier from being broken is called data hiding or information hiding . This protection is enforced by the compiler at compile time. In our original Circle class (v0.1) in Unit 4 , we did not specify any access modifier -- this amount of using the default modifier, the meaning of which is not our concern right now 1 For a start, we will explicitly indicate private or public for all our methods and fields. 1 2 3 4 5 6 7 8 9 10 // Circle v0.2 class Circle { private double x ; private double y ; private double r ; public double getArea () { return 3.141592653589793 * r * r ; }; } Now the fields x , y , and r are hidden behind the abstraction barrier of the class Circle . Note that these fields are not accessible and modifiable outside of the class Circle , but they can be accessed and modified within Circle (inside the abstraction barrier), such as in the methods getArea . Breaking Python's Abstraction Barrier Python tries to prevent accidental access to internal representation by having a convention of prefixing the internal variables with _ (one underscore) or __ (two underscores). This method, however, does not prevent a lazy programmer from directly accessing the variables and possibly planting a bug/error that will surface later. Constructors With data hiding, we completely isolate the internal representation of a class using an abstraction barrier. But, with no way for the client of the class to modify the fields directly, how can the client initialize the fields in a class? To get around this, it is common for a class to provide methods to initialize these internal fields. A method that initializes an object is called a constructor . A constructor method is a special method within the class. It cannot be called directly but is invoked automatically when an object is instantiated. In Java, a constructor method has the same name as the class and has no return type . A constructor can take in arguments just like other functions. Let's add a constructor to our Circle class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Circle v0.3 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; }; } Now, to create a Circle object, we need to pass in three arguments: 1 Circle c = new Circle(0.0, 0.5, 10.0); Constructor in Python and JavaScript In Python, the constructor is the __init__ method. In JavaScript, the constructor is simply called constructor . The this Keyword The code above also introduces the this keyword. this is a reference variable that refers back to self, and is used to distinguish between two variables of the same name. In the example above, this.x = x means we want to set the field x of this object to the parameter x passed into the constructor. Now that you have been introduced to this , we have also updated the method body of getArea and replaced r with this.r . Although there is nothing syntactically incorrect about using r , sticking to the idiom of referring to members through the this reference makes the code easier to understand to readers. We are making it explicit that we are referring to a field in the class, rather than a local variable or a parameter. The other access modifier is protected . Again, we do not want to worry about this modifier for now. \u21a9","title":"5. Information Hiding"},{"location":"05-infohiding.html#unit-5-information-hiding","text":"After taking this unit, students should: understand the drawback of breaking the abstraction barrier understand the concept of information hiding to enforce the abstraction barrier understand how Java uses access modifiers to enforce information hiding understand what is a constructor and how to write one in Java","title":"Unit 5: Information Hiding"},{"location":"05-infohiding.html#breaking-the-abstraction-barrier","text":"In the ideal case, the code above the abstraction barrier would just call the provided interface to use the composite data type. There, however, may be cases where a programmer may intentionally or accidentally break the abstraction barrier. Consider the case of Circle above, where we modify the radius r directly with c.r = 10 . In doing so, we, as the client to Circle , make an explicit assumption of how Circle implements a circle. The implementation details have been leaked outside the abstraction barrier. Now, if the implementer wishes to change the representation, to say, store the diameter, instead. It would invalidate the code that the client has written! The client will have to carefully change all the code that makes the assumption, and modify accordingly, increasing the chances of introducing a bug.","title":"Breaking the Abstraction Barrier"},{"location":"05-infohiding.html#data-hiding","text":"Many OO languages allow programmers to explicitly specify if a field or a method can be accessed from outside the abstraction barrier. Java, for instance, supports private and public access modifiers[^5]. A field or a method that is declared as private cannot be accessed from outside the class, and can only be accessed within the class. On the other hand, as you can guess, a public field or method can be accessed, modified, or invoked from outside the class. Such a mechanism to protect the abstraction barrier from being broken is called data hiding or information hiding . This protection is enforced by the compiler at compile time. In our original Circle class (v0.1) in Unit 4 , we did not specify any access modifier -- this amount of using the default modifier, the meaning of which is not our concern right now 1 For a start, we will explicitly indicate private or public for all our methods and fields. 1 2 3 4 5 6 7 8 9 10 // Circle v0.2 class Circle { private double x ; private double y ; private double r ; public double getArea () { return 3.141592653589793 * r * r ; }; } Now the fields x , y , and r are hidden behind the abstraction barrier of the class Circle . Note that these fields are not accessible and modifiable outside of the class Circle , but they can be accessed and modified within Circle (inside the abstraction barrier), such as in the methods getArea . Breaking Python's Abstraction Barrier Python tries to prevent accidental access to internal representation by having a convention of prefixing the internal variables with _ (one underscore) or __ (two underscores). This method, however, does not prevent a lazy programmer from directly accessing the variables and possibly planting a bug/error that will surface later.","title":"Data Hiding"},{"location":"05-infohiding.html#constructors","text":"With data hiding, we completely isolate the internal representation of a class using an abstraction barrier. But, with no way for the client of the class to modify the fields directly, how can the client initialize the fields in a class? To get around this, it is common for a class to provide methods to initialize these internal fields. A method that initializes an object is called a constructor . A constructor method is a special method within the class. It cannot be called directly but is invoked automatically when an object is instantiated. In Java, a constructor method has the same name as the class and has no return type . A constructor can take in arguments just like other functions. Let's add a constructor to our Circle class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Circle v0.3 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; }; } Now, to create a Circle object, we need to pass in three arguments: 1 Circle c = new Circle(0.0, 0.5, 10.0); Constructor in Python and JavaScript In Python, the constructor is the __init__ method. In JavaScript, the constructor is simply called constructor .","title":"Constructors"},{"location":"05-infohiding.html#the-this-keyword","text":"The code above also introduces the this keyword. this is a reference variable that refers back to self, and is used to distinguish between two variables of the same name. In the example above, this.x = x means we want to set the field x of this object to the parameter x passed into the constructor. Now that you have been introduced to this , we have also updated the method body of getArea and replaced r with this.r . Although there is nothing syntactically incorrect about using r , sticking to the idiom of referring to members through the this reference makes the code easier to understand to readers. We are making it explicit that we are referring to a field in the class, rather than a local variable or a parameter. The other access modifier is protected . Again, we do not want to worry about this modifier for now. \u21a9","title":"The this Keyword"},{"location":"06-tell-dont-ask.html","text":"Unit 6: Tell, Don't Ask After taking this unit, students should: understand what accessor and mutator are used for, and why not to use them understand the principle of \"Tell, Don't Ask\" Accessors and Mutators Similar to providing constructors, a class should also provide methods to retrieve or modify the properties of the object. These methods are called the accessor (or getter ) or mutator (or setter ). The use of accessor and mutator methods is a bit controversial. Suppose that we provide an accessor method and a mutator method for every private field, then we are exposing the internal representation, therefore breaking the encapsulation. For instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Circle v0.4 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getX () { return this . x ; } public void setX ( double x ) { this . x = x ; } public double getY () { return this . y ; } public void setY ( double y ) { this . y = y ; } public double getR () { return this . r ; } public void setR ( double r ) { this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; }; } The \"Tell Don't Ask\" Principle The mutators and accessors above are pretty pointless. If we need to know the internal and do something with it, then we are breaking the abstraction barrier. The right approach is to implement a method within the class that does whatever we want the class to do. For instance, suppose that we want to know the circumference of the circle c , one approach would be: 1 double circumference = 2 * c . getR () * 3.1415926 ; where c is a Circle object. A better approach would be to add a new method getCircumference() in the Circle class, and call it instead: 1 double circumference = c . getCircumference (); The better approach involves writing a few more lines of code to implement the method, but it keeps the encapsulation intact. If one fine day, the implementer of Circle decided to store the diameter of the circle instead of the radius, then only the implementer needs to change the implementation of getCircumference . The client does not have to change anything. The principle around which we can think about this is the \"Tell, Don't Ask\" principle. The client should tell a Circle object what to do (compute the circumference), instead of asking \"what is your radius?\" to get the value of a field then perform the computation on the object's behalf. While there are situations where we can't avoid using accessor or modifier in a class, for beginning OO programmers like yourself, it is better to not define classes with any accessor and modifier, and forces yourselves to think in the OO way -- to tell an object what task to perform as a client, and then implement this task within the class as a method as the implementer. Further Reading Tell Don't Ask by Martin Fowler Why getters and setters are evil , by Allen Holub, JavaWorld Getters and setters are evil. Period , by Yegor Bygayenko.","title":"6. Tell, Don't Ask"},{"location":"06-tell-dont-ask.html#unit-6-tell-dont-ask","text":"After taking this unit, students should: understand what accessor and mutator are used for, and why not to use them understand the principle of \"Tell, Don't Ask\"","title":"Unit 6: Tell, Don't Ask"},{"location":"06-tell-dont-ask.html#accessors-and-mutators","text":"Similar to providing constructors, a class should also provide methods to retrieve or modify the properties of the object. These methods are called the accessor (or getter ) or mutator (or setter ). The use of accessor and mutator methods is a bit controversial. Suppose that we provide an accessor method and a mutator method for every private field, then we are exposing the internal representation, therefore breaking the encapsulation. For instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Circle v0.4 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getX () { return this . x ; } public void setX ( double x ) { this . x = x ; } public double getY () { return this . y ; } public void setY ( double y ) { this . y = y ; } public double getR () { return this . r ; } public void setR ( double r ) { this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; }; }","title":"Accessors and Mutators"},{"location":"06-tell-dont-ask.html#the-tell-dont-ask-principle","text":"The mutators and accessors above are pretty pointless. If we need to know the internal and do something with it, then we are breaking the abstraction barrier. The right approach is to implement a method within the class that does whatever we want the class to do. For instance, suppose that we want to know the circumference of the circle c , one approach would be: 1 double circumference = 2 * c . getR () * 3.1415926 ; where c is a Circle object. A better approach would be to add a new method getCircumference() in the Circle class, and call it instead: 1 double circumference = c . getCircumference (); The better approach involves writing a few more lines of code to implement the method, but it keeps the encapsulation intact. If one fine day, the implementer of Circle decided to store the diameter of the circle instead of the radius, then only the implementer needs to change the implementation of getCircumference . The client does not have to change anything. The principle around which we can think about this is the \"Tell, Don't Ask\" principle. The client should tell a Circle object what to do (compute the circumference), instead of asking \"what is your radius?\" to get the value of a field then perform the computation on the object's behalf. While there are situations where we can't avoid using accessor or modifier in a class, for beginning OO programmers like yourself, it is better to not define classes with any accessor and modifier, and forces yourselves to think in the OO way -- to tell an object what task to perform as a client, and then implement this task within the class as a method as the implementer.","title":"The \"Tell Don't Ask\" Principle"},{"location":"06-tell-dont-ask.html#further-reading","text":"Tell Don't Ask by Martin Fowler Why getters and setters are evil , by Allen Holub, JavaWorld Getters and setters are evil. Period , by Yegor Bygayenko.","title":"Further Reading"},{"location":"07-static.html","text":"Unit 7: Class Instance and Methods Class Fields and Methods Let's look at the implementation of getArea() above. We use the constant \\(\\pi\\) but hardcoded it as 3.1415926. Hardcoding such a magic number is a no-no in terms of coding style. This constant can appear in more than one places. If we hardcode such a number and want to change its precision later, we would need to trace down and change every occurrence. Every time we need to use \\(\\pi\\) , we have to remember or look up what is the precision that we use. Not only does this practice introduce more work, it is also likely to introduce bugs. In C, we define \\(\\pi\\) as a macro constant M_PI . But how should we do this in Java? This is where the ideal that a program consists of only objects with internal states that communicate with each other feel a bit constraining. The constant \\(\\pi\\) is universal, and does not really belong to any object (the value of \\(\\pi\\) is the same for every circle!). Another example: if we define a method sqrt() that computes the square root of a given number, this is a general function that is not associated with any object as well. A solution to this is to associate these global values and functions with a class instead of with an object . For instance. Java predefines a Math class 1 that is populated with constants PI and E (for Euler's number \\(e\\) ), along with a long list of mathematical functions. To associate a method or a field with a class in Java, we declare them with the static keyword. We can additionally add a keyword final to indicate that the value of the field will not change 2 . 1 2 3 4 5 6 class Math { : public static final double PI = 3.141592653589793 ; : : } We call these fields and methods that are associated with a class as class fields and class methods , and fields and methods that are associated with an object as instance fields and instance methods . Class Fields and Methods in Python Note that, in Python, any variable declared within a class block is a class field: 1 2 3 class Circle : x = 0 y = 0 In the above example, x and y are class fields, not instance fields. Example: The Circle class Now, let revise our Circle class to improve the code and make it a little more complete: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private double x ; // x-coordinate of the center private double y ; // y-coordinate of the center private double r ; // the length of the radius /** * Create a circle centered on (centerX, centerY) with given radius */ public Circle ( double centerX , double centerY , double radius ) { x = centerX ; y = centerY ; r = radius ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * r * r ; } /** * Return the circumference of the circle. */ public double getCircumference () { return Math . PI * 2 * r ; } /** * Move the center of the circle to the new position (newX, newY) */ public void moveTo ( double newX , double newY ) { x = newX ; y = newY ; } /** * Return true if the given point (testX, testY) is within the circle. */ public boolean contains ( double testX , double testY ) { return false ; // TODO: left as an exercise } } Creating and Interacting with Circle objects To use the Circle class, we can either: create a main() function, compile and link with the Circle class, and create an executable program, just like we usually do with a C program, OR use jshell , which is part of Java 9 (but not earlier versions). jshell provides a read-evaluate-print loop (REPL) to help us quickly try out various features of Java. We will write a complete Java program with main() later in this class, but for now, we will use jshell to demonstrate the various language features of Java 2 . The demonstration below loads the Circle class written above (with the contains method completed) from a file named Circle.java 3 , and creates two Circle objects, c1 and c2 . We use the new keyword to tell Java to create an object of type Circle here, passing in the center and the radius. 1 Circle c1 = new Circle ( 0 , 0 , 100 ); Reference Type vs. Primitive Type The variable c1 actually stores an abstraction over a reference to the Circle object, instead of the object itself. All objects are stored as references in Java . The other variable type supported in Java is primitive type. A variable of primitive type stores the value instead of a reference to the value. Java supports eight primitive data types: byte , short , int , long , float , double , boolean and char . If you are familiar with C, these data types should not be foreign to you. One important difference is that a char variable stores a 16-bit Unicode character, not an 8-bit character like in C. Java uses the type byte for that. The other notable difference is that Java defines true and false as possible value to a boolean , unlike C which uses 0 for false and non- 0 for true. You can read all about Java variables and primitive data types in Oracle's Java Tutorial. Type Safety Some languages are stricter in terms of type \"compatibility\" than others. C compilers, however, are not very strict. If it detects something strange with the type you used, it will issue a warning, but still let your code compiles and runs. Take: 1 2 3 4 5 #include <stdio.h> int main () { printf ( \"%d \\n \" , \"cs2030\" ); } In Line 4, we treat the address to a string as integer. This generates a compiler's warning. In C, you can type cast a variable from one type into another, i.e., force the compiler to treat a variable of one type as another type. The compiler would listen and do that for you. The following code would print out gibberish and would compile perfectly without error. 1 2 3 4 5 #include <stdio.h> int main () { printf ( \"%d \\n \" , ( int ) \"cs2030\" ); } Such flexibility and loose rules for type compatibility could be useful, if you know what you are doing, but for most programmers, it could be a major source of unintentional bugs, especially if one does not pay attention to compiler's warning or one forces the warning to go away without fully understanding what is going on. Java is very strict when it comes to type checking, and is one of the type-safe languages. Java ensures that basic operations (such as + , - , etc) and method calls apply to values in a way that makes sense. If you try to pull the same trick as above, you will receive an error: Exercise In the example above, we implemented a class Circle . There, we store and pass around two double variables that correspond to the x-coordinate and y-coordinate of a point. The code would be neater if we create a second class Point that encapsulates the concept of a point on a 2D plane and the operations on points. Implement a new class Point and modify the class Circle to use the class Point . Pay attention to what methods and fields (if any) you expose as public outside of the abstraction barrier of a Point object. You will need to use jshell from Java 1.9 (or JDK 9) to interact with your new classes. Use jshell to try out the following. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { public static int x = 1 ; public int y = 5 ; void incrX () { x = x + 1 ; } void incrY () { y = y + 1 ; } } A a1 = new A (); A a2 = new A (); After executing a1.x = 10 , what is the value of a2.x ? After executing a1.y = 10 , what is the value of a2.y ? Is A.x = 3 a valid statement? Is A.y = 3 a valid statement? Note: Even though a1.x is valid, it is considered a bad programming practice to access a class field through an instance variable (e.g., a1.x ). The proper way to do it is to use the class name A.x ). Consider the following two classes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class A { private int x ; public void changeSelf () { x = 1 ; } public void changeAnother ( A a ) { a . x = 1 ; } } class B { public void changeAnother ( A a ) { a . x = 1 ; } } Which line(s) above violate the private access modifier of x ? The class Math is provided by the package java.lang in Java. A package is simply a set of related classes (and interfaces, but I have not told you what is an interface yet). To use this class, we need to add the line import java.lang.Math at the beginning of our program. \u21a9 You can download and install jshell yourself, as part of Java Development Kit version 9 (JDK 9) \u21a9 \u21a9 We use the convention of one public class per file, name the file with the exact name of the class (including capitalization), and include the extension .java to the filename. \u21a9","title":"Unit 7: Class Instance and Methods"},{"location":"07-static.html#unit-7-class-instance-and-methods","text":"","title":"Unit 7: Class Instance and Methods"},{"location":"07-static.html#class-fields-and-methods","text":"Let's look at the implementation of getArea() above. We use the constant \\(\\pi\\) but hardcoded it as 3.1415926. Hardcoding such a magic number is a no-no in terms of coding style. This constant can appear in more than one places. If we hardcode such a number and want to change its precision later, we would need to trace down and change every occurrence. Every time we need to use \\(\\pi\\) , we have to remember or look up what is the precision that we use. Not only does this practice introduce more work, it is also likely to introduce bugs. In C, we define \\(\\pi\\) as a macro constant M_PI . But how should we do this in Java? This is where the ideal that a program consists of only objects with internal states that communicate with each other feel a bit constraining. The constant \\(\\pi\\) is universal, and does not really belong to any object (the value of \\(\\pi\\) is the same for every circle!). Another example: if we define a method sqrt() that computes the square root of a given number, this is a general function that is not associated with any object as well. A solution to this is to associate these global values and functions with a class instead of with an object . For instance. Java predefines a Math class 1 that is populated with constants PI and E (for Euler's number \\(e\\) ), along with a long list of mathematical functions. To associate a method or a field with a class in Java, we declare them with the static keyword. We can additionally add a keyword final to indicate that the value of the field will not change 2 . 1 2 3 4 5 6 class Math { : public static final double PI = 3.141592653589793 ; : : } We call these fields and methods that are associated with a class as class fields and class methods , and fields and methods that are associated with an object as instance fields and instance methods . Class Fields and Methods in Python Note that, in Python, any variable declared within a class block is a class field: 1 2 3 class Circle : x = 0 y = 0 In the above example, x and y are class fields, not instance fields.","title":"Class Fields and Methods"},{"location":"07-static.html#example-the-circle-class","text":"Now, let revise our Circle class to improve the code and make it a little more complete: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private double x ; // x-coordinate of the center private double y ; // y-coordinate of the center private double r ; // the length of the radius /** * Create a circle centered on (centerX, centerY) with given radius */ public Circle ( double centerX , double centerY , double radius ) { x = centerX ; y = centerY ; r = radius ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * r * r ; } /** * Return the circumference of the circle. */ public double getCircumference () { return Math . PI * 2 * r ; } /** * Move the center of the circle to the new position (newX, newY) */ public void moveTo ( double newX , double newY ) { x = newX ; y = newY ; } /** * Return true if the given point (testX, testY) is within the circle. */ public boolean contains ( double testX , double testY ) { return false ; // TODO: left as an exercise } }","title":"Example: The Circle class"},{"location":"07-static.html#creating-and-interacting-with-circle-objects","text":"To use the Circle class, we can either: create a main() function, compile and link with the Circle class, and create an executable program, just like we usually do with a C program, OR use jshell , which is part of Java 9 (but not earlier versions). jshell provides a read-evaluate-print loop (REPL) to help us quickly try out various features of Java. We will write a complete Java program with main() later in this class, but for now, we will use jshell to demonstrate the various language features of Java 2 . The demonstration below loads the Circle class written above (with the contains method completed) from a file named Circle.java 3 , and creates two Circle objects, c1 and c2 . We use the new keyword to tell Java to create an object of type Circle here, passing in the center and the radius. 1 Circle c1 = new Circle ( 0 , 0 , 100 );","title":"Creating and Interacting with Circle objects"},{"location":"07-static.html#reference-type-vs-primitive-type","text":"The variable c1 actually stores an abstraction over a reference to the Circle object, instead of the object itself. All objects are stored as references in Java . The other variable type supported in Java is primitive type. A variable of primitive type stores the value instead of a reference to the value. Java supports eight primitive data types: byte , short , int , long , float , double , boolean and char . If you are familiar with C, these data types should not be foreign to you. One important difference is that a char variable stores a 16-bit Unicode character, not an 8-bit character like in C. Java uses the type byte for that. The other notable difference is that Java defines true and false as possible value to a boolean , unlike C which uses 0 for false and non- 0 for true. You can read all about Java variables and primitive data types in Oracle's Java Tutorial.","title":"Reference Type vs. Primitive Type"},{"location":"07-static.html#type-safety","text":"Some languages are stricter in terms of type \"compatibility\" than others. C compilers, however, are not very strict. If it detects something strange with the type you used, it will issue a warning, but still let your code compiles and runs. Take: 1 2 3 4 5 #include <stdio.h> int main () { printf ( \"%d \\n \" , \"cs2030\" ); } In Line 4, we treat the address to a string as integer. This generates a compiler's warning. In C, you can type cast a variable from one type into another, i.e., force the compiler to treat a variable of one type as another type. The compiler would listen and do that for you. The following code would print out gibberish and would compile perfectly without error. 1 2 3 4 5 #include <stdio.h> int main () { printf ( \"%d \\n \" , ( int ) \"cs2030\" ); } Such flexibility and loose rules for type compatibility could be useful, if you know what you are doing, but for most programmers, it could be a major source of unintentional bugs, especially if one does not pay attention to compiler's warning or one forces the warning to go away without fully understanding what is going on. Java is very strict when it comes to type checking, and is one of the type-safe languages. Java ensures that basic operations (such as + , - , etc) and method calls apply to values in a way that makes sense. If you try to pull the same trick as above, you will receive an error:","title":"Type Safety"},{"location":"07-static.html#exercise","text":"In the example above, we implemented a class Circle . There, we store and pass around two double variables that correspond to the x-coordinate and y-coordinate of a point. The code would be neater if we create a second class Point that encapsulates the concept of a point on a 2D plane and the operations on points. Implement a new class Point and modify the class Circle to use the class Point . Pay attention to what methods and fields (if any) you expose as public outside of the abstraction barrier of a Point object. You will need to use jshell from Java 1.9 (or JDK 9) to interact with your new classes. Use jshell to try out the following. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { public static int x = 1 ; public int y = 5 ; void incrX () { x = x + 1 ; } void incrY () { y = y + 1 ; } } A a1 = new A (); A a2 = new A (); After executing a1.x = 10 , what is the value of a2.x ? After executing a1.y = 10 , what is the value of a2.y ? Is A.x = 3 a valid statement? Is A.y = 3 a valid statement? Note: Even though a1.x is valid, it is considered a bad programming practice to access a class field through an instance variable (e.g., a1.x ). The proper way to do it is to use the class name A.x ). Consider the following two classes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class A { private int x ; public void changeSelf () { x = 1 ; } public void changeAnother ( A a ) { a . x = 1 ; } } class B { public void changeAnother ( A a ) { a . x = 1 ; } } Which line(s) above violate the private access modifier of x ? The class Math is provided by the package java.lang in Java. A package is simply a set of related classes (and interfaces, but I have not told you what is an interface yet). To use this class, we need to add the line import java.lang.Math at the beginning of our program. \u21a9 You can download and install jshell yourself, as part of Java Development Kit version 9 (JDK 9) \u21a9 \u21a9 We use the convention of one public class per file, name the file with the exact name of the class (including capitalization), and include the extension .java to the filename. \u21a9","title":"Exercise"},{"location":"preface.html","text":"Preface What is this book about? This book is a result of designing and teaching a new module, CS2030 Programming Methodology II, at the National University of Singapore (NUS), starting in 2017. CS2030 is designed for students who have gone through a typical basic programming module module and have learned about problem solving with simple programming constructs such as loops, conditions, and functions. In a typical introductory programming module, such as CS1010 and its variants at NUS, students tend to write small program (in the order of tens or hundreds of lines of code) to solve a programming homework, work alone on their code, and move on to solve the next problem once the homework is done. The first aim of CS2030 is to change the students' mindset and to make them learn to write software that will continue to evolve as software requirement changes, and to write software that will be read and modified by other programmers (including their future selves). The second aim of CS2030 is to level-up the complexity of programs that the students write, from order of hundreds of lines to thousands of lines. CS2030 will bridge the students between writing toy programs to solve specific problem in CS1010 and writing larger real-world software in their later modules, such as CS2103 Software Engineering. A programming language is the medium in which programmers can express their intention and construct software, and thus is critical to supporting the aims above. With the appropriate features and tools, once can tame the complexity of software, make the code written friendlier to other programmers, and easier to evolve. The third aim of CS2030 is thus to expand the students' mind on different ways one can construct software and the principles behind some of the programming langauge constructs. In particular, CS2030 focuses on objects, types, and functions, as three key constructs towards building programmer-friendly software. It covers both object-oriented paradigm and functional paradigm as two different approaches to construct software, with a strong emphasis on type safety. The final aim of CS2030 is to introduce students to programming language concepts, to bridge them from introductory programming to advanced modules such as programming language design and implementations. Part of CS2030 introduces students to the design decisions behind some of the constraints and the workings behind the programming language compilation and execution, giving them a glimpse inside the programming system that so far has been mostly treated as a black box in introductory modules. This book serves as a guide the students in CS2030 and other students who might be interested in learning to build better, more complex, programmer-friendly software, having learned introductory programming. The Choice of Java We decided to use one programming language throughout the module and throughout this book. This decision means that we need to pick a language with static typing and strongly typed, and support both object-oriented and functional of programming. Considering multiple factors, we decided to choose Java for CS2030, for its popularity, syntax familiarity, and smoother transitions to later modules in the NUS computing curriculum. While Java is definitely not the most elegant programming language when expressing programs in functional style, we hope that students and readers can still learn the principles of functional programming and apply it in other programming languages. This choice is a trade off between having to switch to a different language in the middle of a module. What This Book Is Not About This is not a book on Java programming. We will not comprehensively cover Java syntax and features, except those relevant to the concepts we wish to teach. In fact, we will avoid and even ban students from using certain Java features (such as var ) for pedagogical purposes. This is not a book on software engineering either. Software engineering is a broad discipline on its own and deserves another book. Further, there are already many well-written books on software engineering out there. Rather, this book is about the programming principles and constructs on top of which programmers can design better software. To motivate the importance of these principles and constructs and see how they can be used, we will inevitably cover some of the software engineering design principles, such as the Liskov's Substitution Principle (the L in SOLID), Tell-Don't-Ask, Composition over Inheritence, etc. But we will not comprehensively cover object-oriented design or software design in general (e.g., we will not cover S,O,I,D in SOLID).","title":"Preface"},{"location":"preface.html#preface","text":"","title":"Preface"},{"location":"preface.html#what-is-this-book-about","text":"This book is a result of designing and teaching a new module, CS2030 Programming Methodology II, at the National University of Singapore (NUS), starting in 2017. CS2030 is designed for students who have gone through a typical basic programming module module and have learned about problem solving with simple programming constructs such as loops, conditions, and functions. In a typical introductory programming module, such as CS1010 and its variants at NUS, students tend to write small program (in the order of tens or hundreds of lines of code) to solve a programming homework, work alone on their code, and move on to solve the next problem once the homework is done. The first aim of CS2030 is to change the students' mindset and to make them learn to write software that will continue to evolve as software requirement changes, and to write software that will be read and modified by other programmers (including their future selves). The second aim of CS2030 is to level-up the complexity of programs that the students write, from order of hundreds of lines to thousands of lines. CS2030 will bridge the students between writing toy programs to solve specific problem in CS1010 and writing larger real-world software in their later modules, such as CS2103 Software Engineering. A programming language is the medium in which programmers can express their intention and construct software, and thus is critical to supporting the aims above. With the appropriate features and tools, once can tame the complexity of software, make the code written friendlier to other programmers, and easier to evolve. The third aim of CS2030 is thus to expand the students' mind on different ways one can construct software and the principles behind some of the programming langauge constructs. In particular, CS2030 focuses on objects, types, and functions, as three key constructs towards building programmer-friendly software. It covers both object-oriented paradigm and functional paradigm as two different approaches to construct software, with a strong emphasis on type safety. The final aim of CS2030 is to introduce students to programming language concepts, to bridge them from introductory programming to advanced modules such as programming language design and implementations. Part of CS2030 introduces students to the design decisions behind some of the constraints and the workings behind the programming language compilation and execution, giving them a glimpse inside the programming system that so far has been mostly treated as a black box in introductory modules. This book serves as a guide the students in CS2030 and other students who might be interested in learning to build better, more complex, programmer-friendly software, having learned introductory programming.","title":"What is this book about?"},{"location":"preface.html#the-choice-of-java","text":"We decided to use one programming language throughout the module and throughout this book. This decision means that we need to pick a language with static typing and strongly typed, and support both object-oriented and functional of programming. Considering multiple factors, we decided to choose Java for CS2030, for its popularity, syntax familiarity, and smoother transitions to later modules in the NUS computing curriculum. While Java is definitely not the most elegant programming language when expressing programs in functional style, we hope that students and readers can still learn the principles of functional programming and apply it in other programming languages. This choice is a trade off between having to switch to a different language in the middle of a module.","title":"The Choice of Java"},{"location":"preface.html#what-this-book-is-not-about","text":"This is not a book on Java programming. We will not comprehensively cover Java syntax and features, except those relevant to the concepts we wish to teach. In fact, we will avoid and even ban students from using certain Java features (such as var ) for pedagogical purposes. This is not a book on software engineering either. Software engineering is a broad discipline on its own and deserves another book. Further, there are already many well-written books on software engineering out there. Rather, this book is about the programming principles and constructs on top of which programmers can design better software. To motivate the importance of these principles and constructs and see how they can be used, we will inevitably cover some of the software engineering design principles, such as the Liskov's Substitution Principle (the L in SOLID), Tell-Don't-Ask, Composition over Inheritence, etc. But we will not comprehensively cover object-oriented design or software design in general (e.g., we will not cover S,O,I,D in SOLID).","title":"What This Book Is Not About"}]}